/* Generated by re2c 0.13.5 on Mon Jul  9 00:08:28 2012 */
#line 1 "lexer.cc"
/* ---------------------------------------------------
 Copyright 2012 Taras Zakharko
 
 This file is part of the ToolboxSearch R package.
 
 ToolboxSearch is free software: you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the Free
 Software Foundation, either version 2 of the License, or (at your option)
 any later version.
 
 ToolboxSearch is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 more details.
--------------------------------------------------- */



/* ---------------------------------------------------
 This is the re2c lexer definition for the corpus query language used in ToolboxSearch

 Use re2c to create the lexer source file from this definition
--------------------------------------------------- */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>


typedef struct {
	int type;
	SEXP token;
} token_t;


const char *scan(const char *p, token_t* token)
{
	const char *p0 = p;
	const char *_p  = p;
	const char *last = p + strlen(p);
	
	#define YYFILL(n) {Rprintf("End of line reached before the token could be completed!\n"); return(NULL);}

#line 47 "<stdout>"
	{
		unsigned char yych;
		unsigned int yyaccept = 0;

		yych = (unsigned char)*p;
		switch (yych) {
		case 0x00:	goto yy2;
		case '\t':
		case '\n':
		case ' ':	goto yy7;
		case '!':	goto yy12;
		case '"':	goto yy6;
		case '#':	goto yy39;
		case '$':	goto yy26;
		case '\'':	goto yy4;
		case '(':	goto yy14;
		case ')':	goto yy16;
		case '*':	goto yy30;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':	goto yy9;
		case ':':	goto yy32;
		case '=':	goto yy11;
		case '@':	goto yy28;
		case 'A':
		case 'a':	goto yy34;
		case 'B':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case 'b':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':	goto yy41;
		case 'C':
		case 'c':	goto yy37;
		case 'N':
		case 'n':	goto yy38;
		case 'O':
		case 'o':	goto yy36;
		case '[':	goto yy18;
		case ']':	goto yy20;
		case '{':	goto yy22;
		case '}':	goto yy24;
		default:	goto yy42;
		}
yy2:
		++p;
#line 51 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected EOL\n"); 
#endif
			return(NULL);
		}
#line 146 "<stdout>"
yy4:
		yyaccept = 0;
		yych = (unsigned char)*(_p = ++p);
		switch (yych) {
		case '\n':	goto yy5;
		default:	goto yy86;
		}
yy5:
#line 292 "lexer.cc"
		{
			REprintf("ERROR: unexpected character '%c'\n", *(p-1)); 
			return(NULL);
		}
#line 160 "<stdout>"
yy6:
		yyaccept = 0;
		yych = (unsigned char)*(_p = ++p);
		switch (yych) {
		case '\n':	goto yy5;
		default:	goto yy78;
		}
yy7:
		++p;
		yych = (unsigned char)*p;
		goto yy76;
yy8:
#line 78 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected %d whitespaces\n", p-p0); 
#endif
			token->token = R_NilValue;
			token->type = 0;
			return(p);
		}
#line 182 "<stdout>"
yy9:
		yyaccept = 1;
		yych = (unsigned char)*(_p = ++p);
		goto yy72;
yy10:
#line 90 "lexer.cc"
		{
			char *str;
#ifdef DEBUG		
			Rprintf("Detected number <%.*s>\n", p-p0, p0); 
#endif
			token->token = make_str(mkCharLen(p0, p - p0));
			token->type = TOK_NUMBER;
			return(p);
		}
#line 198 "<stdout>"
yy11:
		yych = (unsigned char)*++p;
		switch (yych) {
		case '=':	goto yy67;
		case '~':	goto yy65;
		default:	goto yy5;
		}
yy12:
		++p;
		switch ((yych = (unsigned char)*p)) {
		case '~':	goto yy63;
		default:	goto yy13;
		}
yy13:
#line 128 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected !\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_EXCL;
			return(p);
		}
#line 222 "<stdout>"
yy14:
		++p;
#line 137 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected (\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_LPAREN;
			return(p);
		}
#line 234 "<stdout>"
yy16:
		++p;
#line 146 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected )\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_RPAREN;
			return(p);
		}
#line 246 "<stdout>"
yy18:
		++p;
#line 155 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected [\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_LSQBR;
			return(p);
		}
#line 258 "<stdout>"
yy20:
		++p;
#line 164 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected ]\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_RSQBR;
			return(p);
		}
#line 270 "<stdout>"
yy22:
		++p;
#line 174 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected {\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_LCURVBR;
			return(p);
		}
#line 282 "<stdout>"
yy24:
		++p;
#line 183 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected }\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_RCURVBR;
			return(p);
		}
#line 294 "<stdout>"
yy26:
		++p;
#line 194 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected $\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_DOLLAR;
			return(p);
		}
#line 306 "<stdout>"
yy28:
		++p;
#line 203 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected @\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_AT;
			return(p);
		}
#line 318 "<stdout>"
yy30:
		++p;
#line 212 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected *\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_STAR;
			return(p);
		}
#line 330 "<stdout>"
yy32:
		++p;
#line 221 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected :\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_SEMICOLON;
			return(p);
		}
#line 342 "<stdout>"
yy34:
		++p;
		switch ((yych = (unsigned char)*p)) {
		case 'N':
		case 'n':	goto yy58;
		default:	goto yy44;
		}
yy35:
#line 284 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected literal <%.*s>\n", p-p0, p0); 
#endif
			token->token = make_str(mkCharLen(p0, p - p0));
			token->type = TOK_LITERAL;
			return(p);
		}
#line 360 "<stdout>"
yy36:
		yych = (unsigned char)*++p;
		switch (yych) {
		case 'R':
		case 'r':	goto yy56;
		default:	goto yy44;
		}
yy37:
		yych = (unsigned char)*++p;
		switch (yych) {
		case 'O':
		case 'o':	goto yy48;
		default:	goto yy44;
		}
yy38:
		yych = (unsigned char)*++p;
		switch (yych) {
		case 'O':
		case 'o':	goto yy45;
		default:	goto yy44;
		}
yy39:
		++p;
#line 275 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected BR\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_BR;
			return(p);
		}
#line 393 "<stdout>"
yy41:
		yych = (unsigned char)*++p;
		goto yy44;
yy42:
		yych = (unsigned char)*++p;
		goto yy5;
yy43:
		++p;
		yych = (unsigned char)*p;
yy44:
		switch (yych) {
		case '.':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':	goto yy43;
		default:	goto yy35;
		}
yy45:
		yych = (unsigned char)*++p;
		switch (yych) {
		case 'T':
		case 't':	goto yy46;
		default:	goto yy44;
		}
yy46:
		++p;
		switch ((yych = (unsigned char)*p)) {
		case '.':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':	goto yy43;
		default:	goto yy47;
		}
yy47:
#line 257 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected NOT\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_NOT;
			return(p);
		}
#line 557 "<stdout>"
yy48:
		yych = (unsigned char)*++p;
		switch (yych) {
		case 'N':
		case 'n':	goto yy49;
		default:	goto yy44;
		}
yy49:
		yych = (unsigned char)*++p;
		switch (yych) {
		case 'T':
		case 't':	goto yy50;
		default:	goto yy44;
		}
yy50:
		yych = (unsigned char)*++p;
		switch (yych) {
		case 'A':
		case 'a':	goto yy51;
		default:	goto yy44;
		}
yy51:
		yych = (unsigned char)*++p;
		switch (yych) {
		case 'I':
		case 'i':	goto yy52;
		default:	goto yy44;
		}
yy52:
		yych = (unsigned char)*++p;
		switch (yych) {
		case 'N':
		case 'n':	goto yy53;
		default:	goto yy44;
		}
yy53:
		yych = (unsigned char)*++p;
		switch (yych) {
		case 'S':
		case 's':	goto yy54;
		default:	goto yy44;
		}
yy54:
		++p;
		switch ((yych = (unsigned char)*p)) {
		case '.':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':	goto yy43;
		default:	goto yy55;
		}
yy55:
#line 248 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected NOT\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_CONTAINS;
			return(p);
		}
#line 679 "<stdout>"
yy56:
		++p;
		switch ((yych = (unsigned char)*p)) {
		case '.':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':	goto yy43;
		default:	goto yy57;
		}
yy57:
#line 239 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected OR\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_OR;
			return(p);
		}
#line 759 "<stdout>"
yy58:
		yych = (unsigned char)*++p;
		switch (yych) {
		case 'D':
		case 'd':	goto yy59;
		case 'Y':
		case 'y':	goto yy61;
		default:	goto yy44;
		}
yy59:
		++p;
		switch ((yych = (unsigned char)*p)) {
		case '.':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':	goto yy43;
		default:	goto yy60;
		}
yy60:
#line 230 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected AND\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_AND;
			return(p);
		}
#line 848 "<stdout>"
yy61:
		++p;
		switch ((yych = (unsigned char)*p)) {
		case '.':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':	goto yy43;
		default:	goto yy62;
		}
yy62:
#line 266 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected ANY\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_ANY;
			return(p);
		}
#line 928 "<stdout>"
yy63:
		++p;
#line 110 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected !~\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_NREGEX;
			return(p);
		}
#line 940 "<stdout>"
yy65:
		++p;
#line 119 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected =~\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_REGEX;
			return(p);
		}
#line 952 "<stdout>"
yy67:
		++p;
#line 100 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected ==\n"); 
#endif
			token->token = R_NilValue;
			token->type = TOK_EQ;
			return(p);
		}
#line 964 "<stdout>"
yy69:
		yych = (unsigned char)*++p;
		switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':	goto yy73;
		default:	goto yy70;
		}
yy70:
		p = _p;
		switch (yyaccept) {
		case 0: 	goto yy5;
		case 1: 	goto yy10;
		case 2: 	goto yy79;
		case 3: 	goto yy87;
		}
yy71:
		yyaccept = 1;
		_p = ++p;
		yych = (unsigned char)*p;
yy72:
		switch (yych) {
		case '.':	goto yy69;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':	goto yy71;
		default:	goto yy10;
		}
yy73:
		++p;
		yych = (unsigned char)*p;
		switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':	goto yy73;
		default:	goto yy10;
		}
yy75:
		++p;
		yych = (unsigned char)*p;
yy76:
		switch (yych) {
		case '\t':
		case '\n':
		case ' ':	goto yy75;
		default:	goto yy8;
		}
yy77:
		yyaccept = 2;
		_p = ++p;
		yych = (unsigned char)*p;
yy78:
		switch (yych) {
		case 0x00:	goto yy77;
		case '\n':	goto yy79;
		case '"':	goto yy84;
		case '\\':	goto yy82;
		default:	goto yy80;
		}
yy79:
#line 68 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected string token <%.*s>\n", p-p0, p0); 
#endif
			token->token = make_str(mkCharLen(p0+1, p - p0-2));
			token->type = TOK_STRING;
			return(p);
		}
#line 1055 "<stdout>"
yy80:
		++p;
		yych = (unsigned char)*p;
		switch (yych) {
		case 0x00:	goto yy77;
		case '\n':	goto yy70;
		case '"':	goto yy84;
		case '\\':	goto yy82;
		default:	goto yy80;
		}
yy82:
		++p;
		yych = (unsigned char)*p;
		switch (yych) {
		case 0x00:
		case '"':	goto yy77;
		case '\n':	goto yy70;
		case '\\':	goto yy82;
		default:	goto yy80;
		}
yy84:
		yych = (unsigned char)*++p;
		goto yy79;
yy85:
		yyaccept = 3;
		_p = ++p;
		yych = (unsigned char)*p;
yy86:
		switch (yych) {
		case 0x00:	goto yy85;
		case '\n':	goto yy87;
		case '\'':	goto yy92;
		case '\\':	goto yy90;
		default:	goto yy88;
		}
yy87:
#line 58 "lexer.cc"
		{
#ifdef DEBUG		
			Rprintf("Detected string token <%.*s>\n", p-p0, p0); 
#endif
			if(p>=last) {Rprintf("End of line reached before the token could be completed!\n"); return(NULL);}
			token->token = make_str(mkCharLen(p0+1, p - p0-2));
			token->type = TOK_STRING;
			return(p);
		}
#line 1102 "<stdout>"
yy88:
		++p;
		yych = (unsigned char)*p;
		switch (yych) {
		case 0x00:	goto yy85;
		case '\n':	goto yy70;
		case '\'':	goto yy92;
		case '\\':	goto yy90;
		default:	goto yy88;
		}
yy90:
		++p;
		yych = (unsigned char)*p;
		switch (yych) {
		case 0x00:
		case '\'':	goto yy85;
		case '\n':	goto yy70;
		case '\\':	goto yy90;
		default:	goto yy88;
		}
yy92:
		++p;
		yych = (unsigned char)*p;
		goto yy87;
	}
#line 296 "lexer.cc"

}
