/* ---------------------------------------------------
 Copyright 2012 Taras Zakharko
 
 This file is part of the ToolboxSearch R package.
 
 ToolboxSearch is free software: you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the Free
 Software Foundation, either version 2 of the License, or (at your option)
 any later version.
 
 ToolboxSearch is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 more details.

---------------------------------------------------  
 
 This is the parser code for the corpus query language used by in ToolboxSearch

 It integrates the parser/lexer pair generated by lemon/re2c, respectively. 

 The the core function is 
  
  SEXP parse(SEXP str)

 which is the interface between the C parser and the R code

 The argument of the function is the source string, the result
 is the parsed query. Rather then simply to construct an AST, the
 parser produces tables of unique to-evaluate components (feedback_t type):

 -- table of references (operations which construct object references such as CONTAINS)
 -- table of predications (operations which match object tiers, e.g. $tier =~ 'regex')
 -- table of topos (operatiosn which match object topology)

 Any logical operations will be automatically converted to the partial disjunctive normal form 
 form (deMorgan_transform) in the parser.
--------------------------------------------------- */


#include <R.h>
#include <Rdefines.h>
#include <Rinternals.h>

#include <string.h>
#include <assert.h>

static 
SEXP make_str(SEXP str)
{
	SEXP s;
	
	PROTECT(s = allocVector(STRSXP, 1));
	SET_STRING_ELT(s, 0, str);
	
	return s;
}

static 
void set_class(SEXP o, const char* class)
{
	SEXP class_str;
	
	PROTECT(class_str = allocVector(STRSXP, 1));
	SET_STRING_ELT(class_str, 0, mkChar(class));
	setAttrib(o, R_ClassSymbol, class_str);
	UNPROTECT(1);
}

/*
	TOPO PATTERN SYNTAX TREE
	
	TOPO(list of MATCH statements)
*/
SEXP constructNode_TOPO_PATTERN(SEXP pattern, SEXP next)
{
	UNPROTECT_PTR(next);
	
	if(pattern == R_NilValue) 
	{
		PROTECT(pattern = allocVector(VECSXP, 1));
	}
	 else
	{
		UNPROTECT_PTR(pattern);
		PROTECT(SET_LENGTH(pattern, LENGTH(pattern) + 1));
	}


	SET_VECTOR_ELT(pattern, LENGTH(pattern)-1, next);
	set_class(pattern, "node.TOPO.PATTERN");

	return pattern;
}

SEXP constructNode_TOPO_MATCH_BR()
{
	SEXP result;
	
	PROTECT(result = allocVector(INTSXP, 1));
	INTEGER(result)[0] = -2; // special value for BR
	set_class(result, "node.TOPO.MATCH");

	return result;
}

SEXP constructNode_TOPO_MATCH_ANY()
{
	SEXP result;
	
	PROTECT(result = allocVector(INTSXP, 1));
	INTEGER(result)[0] = -1; // special value for ANY
	set_class(result, "node.TOPO.MATCH");

	return result;
}

SEXP constructNode_TOPO_MATCH_INV(int what)
{
	SEXP result;
	
	PROTECT(result = allocVector(INTSXP, 1));
	INTEGER(result)[0] = what; 
	set_class(result, "node.TOPO.MATCH.INV");

	return result;
}

SEXP constructNode_TOPO_MATCH(int what)
{
	SEXP result;
	
	PROTECT(result = allocVector(INTSXP, 1));
	INTEGER(result)[0] = what; 
	set_class(result, "node.TOPO.MATCH");

	return result;
}


SEXP makeNode_TOPO_MATCH_REPEAT(SEXP what, int min, int max)
{
	SEXP result, range;
	
	UNPROTECT_PTR(what);
	
	PROTECT(result = allocVector(VECSXP, 1));
	PROTECT(range = allocVector(INTSXP, 2));

	set_class(result, "node.TOPO.MATCH.REPEAT");
	
	INTEGER(range)[0] = min;
	if(max <= 0)
		INTEGER(range)[1] = NA_INTEGER; 
	else
	 	INTEGER(range)[1] = max;
	
	SET_VECTOR_ELT(result, 0, what);
	setAttrib(result, install("range"), range);
	
	UNPROTECT(1);

	return result;
}

/*
	References
*/
SEXP constructNode_REFERENCE_VAR(SEXP varname)
{
	SEXP result;
	
	UNPROTECT_PTR(varname);
	
	PROTECT(result = allocVector(STRSXP, 1));
	SET_STRING_ELT(result, 0, STRING_ELT(varname, 0));
	set_class(result, "node.REFERENCE.VAR");

	return result;
}

SEXP constructNode_REFERENCE_OBJ(SEXP level, SEXP predicates)
{
	SEXP result;
	
	if(level != R_NilValue) UNPROTECT_PTR(level);
	if(predicates != R_NilValue) UNPROTECT_PTR(predicates);
	
	PROTECT(result = allocVector(VECSXP, 1));
	
	SET_VECTOR_ELT(result, 0, predicates);
	
	set_class(result, "node.REFERENCE.OBJ");
	setAttrib(result, install("level"), level);

	return result;
}

/*
	Predicates
*/
SEXP constructNode_PREDICATE_ANNOTATION(SEXP ann, SEXP op, SEXP arg)
{
	SEXP result, range;
	
	UNPROTECT_PTR(ann);
	UNPROTECT_PTR(op);
	UNPROTECT_PTR(arg);
	
	PROTECT(result = allocVector(VECSXP, 0));

	set_class(result, "node.PREDICATE.ANNOTATION");
	
	setAttrib(result, install("var"), ann);
	setAttrib(result, install("op"), op);
	setAttrib(result, install("arg1"), arg);
	
	return result;
}

/*
	Obj evaluators
*/

SEXP constructNode_EVAL_PREDICATE(int prednode)
{
	SEXP result;
	
	// alloc the new pattern object
	PROTECT(result = allocVector(INTSXP, 1));
	INTEGER(result)[0] = prednode;
	set_class(result, "node.EVAL.PREDICATE");
			
	return result;
}

SEXP constructNode_EVAL_CONTAINS_OBJECT(int objnode)
{
	SEXP result;
	
	// alloc the new pattern object
	PROTECT(result = allocVector(INTSXP, 1));
	INTEGER(result)[0] = objnode;
	set_class(result, "node.EVAL.CONTAINS.OBJECT");
			
	return result;
}

SEXP constructNode_EVAL_CONTAINS_TOPO(int toponode)
{
	SEXP result;
	
	// alloc the new pattern object
	PROTECT(result = allocVector(INTSXP, 1));
	INTEGER(result)[0] = toponode;
	set_class(result, "node.EVAL.CONTAINS.TOPO");
			
	return result;
}

/*
	Logical operation for eval combinations (need this oly for the parser, as we will convert these to DNF in short time)
*/
SEXP constructNode_and(SEXP a, SEXP b)
{
	SEXP result;
	
	UNPROTECT_PTR(a);
	UNPROTECT_PTR(b);
	
	// alloc the new pattern object
	PROTECT(result = allocVector(VECSXP, 2));
	set_class(result, "node.AND");
	
	// put the data into the pattern
	SET_VECTOR_ELT(result, 0, a);
	SET_VECTOR_ELT(result, 1, b);
		
	return result;
}

SEXP constructNode_or(SEXP a, SEXP b)
{
	SEXP result;
	
	UNPROTECT_PTR(a);
	UNPROTECT_PTR(b);
	
	// alloc the new pattern object
	PROTECT(result = allocVector(VECSXP, 2));
	set_class(result, "node.OR");
	
	// put the data into the pattern
	SET_VECTOR_ELT(result, 0, a);
	SET_VECTOR_ELT(result, 1, b);
		
	return result;
}

SEXP constructNode_not(SEXP a)
{
	SEXP result;
	
	UNPROTECT_PTR(a);
	
	// alloc the new pattern object
	PROTECT(result = allocVector(VECSXP, 1));
	set_class(result, "node.NOT");
	
	// put the data into the pattern
	SET_VECTOR_ELT(result, 0, a);
		
	return result;
}

/*
	The top query definition
*/
SEXP constructNode_DECL_QUERY(SEXP what, SEXP where)
{
	SEXP result;
	
	UNPROTECT_PTR(what);
	UNPROTECT_PTR(where);
	
	PROTECT(result = allocVector(VECSXP, 0));

	set_class(result, "node.DECL.QUERY");
	
	setAttrib(result, install("what"), what);
	setAttrib(result, install("where"), where);
	
	return result;
}

SEXP constructNode_DECL_EXPORTS(SEXP list, int ref)
{
	if(list == R_NilValue) 
	{
		PROTECT(list = allocVector(INTSXP, 1));
	}
	else
	{
		UNPROTECT_PTR(list);
		PROTECT(SET_LENGTH(list, LENGTH(list) + 1));
	}

	INTEGER(list)[LENGTH(list)-1] = ref;
	set_class(list, "node.DECL.EXPORTS");

	return list;
}

SEXP constructNode_DECL_BINDINGS(SEXP list, int vardecl, int objdecl)
{
	SEXP t;
	
	if(list == R_NilValue) 
	{
		PROTECT(list = allocVector(VECSXP, 1));
	}
	else
	{
		UNPROTECT_PTR(list);
		PROTECT(SET_LENGTH(list, LENGTH(list) + 1));
	}
	
	PROTECT(t = allocVector(INTSXP, 2));
	INTEGER(t)[0] = vardecl;
	INTEGER(t)[1] = objdecl;

	SET_VECTOR_ELT(list, LENGTH(list)-1, t);
	UNPROTECT(1);
	
	set_class(list, "node.DECL.BINDINGS");

	return list;
}

static 
int install_node(SEXP *table, SEXP node)
{	
	UNPROTECT_PTR(node);
	
	if(*table != R_NilValue) 
	{
		// try to find if exact copy of node already is a part of the table 	
		for(int i = 0; i < LENGTH(*table); i++)
			if (R_compute_identical(node, VECTOR_ELT(*table, i), 0) == TRUE) return i+1;
	} else
	{
		PROTECT(*table = allocVector(VECSXP, 1));
		SET_VECTOR_ELT(*table, 0, node);
		
		return 1;
	}

	// add one element to the table
	UNPROTECT_PTR(*table);
	PROTECT(SET_LENGTH(*table, LENGTH(*table) + 1));
	
	// put the data into the pattern
	SET_VECTOR_ELT(*table, LENGTH(*table)-1, node);
		
	return LENGTH(*table);	
}

static
SEXP deMorgan_transform(SEXP eval);


static inline
SEXP deMorgan_transform_NOT(SEXP eval)
{
	const char* class; 
	if(eval == R_NilValue) return(R_NilValue);
	class =  CHAR(STRING_ELT(getAttrib(eval, R_ClassSymbol), 0));
	
	if(strcmp(class, "node.OR")==0)
	{
		UNPROTECT_PTR(eval);
		PROTECT(VECTOR_ELT(eval, 0));
		PROTECT(VECTOR_ELT(eval, 1));
		return deMorgan_transform(constructNode_and(constructNode_not(deMorgan_transform(VECTOR_ELT(eval, 0))), constructNode_not(deMorgan_transform(VECTOR_ELT(eval, 1)))));
	} else
	if(strcmp(class, "node.AND")==0)
	{
		UNPROTECT_PTR(eval);
		PROTECT(VECTOR_ELT(eval, 0));
		PROTECT(VECTOR_ELT(eval, 1));
		return deMorgan_transform(constructNode_or(constructNode_not(deMorgan_transform(VECTOR_ELT(eval, 0))), constructNode_not(deMorgan_transform(VECTOR_ELT(eval, 1)))));
	} else
	if(strcmp(class, "node.NOT")==0)
	{
		UNPROTECT_PTR(eval);
		PROTECT(VECTOR_ELT(eval, 0));
		
		eval = VECTOR_ELT(eval, 0);
		
		return deMorgan_transform(eval);
	} else
	{
		return constructNode_not(eval);
	}
}

static
SEXP deMorgan_transform(SEXP eval)
{
	const char* class;
	if(eval == R_NilValue) return(R_NilValue);
	class =  CHAR(STRING_ELT(getAttrib(eval, R_ClassSymbol), 0));
	
	if(strcmp(class, "node.OR")==0)
	{
		UNPROTECT_PTR(eval);
		PROTECT(VECTOR_ELT(eval, 0));
		PROTECT(VECTOR_ELT(eval, 1));
		return constructNode_or(deMorgan_transform(VECTOR_ELT(eval, 0)), deMorgan_transform(VECTOR_ELT(eval, 1)));
	} else
	if(strcmp(class, "node.AND")==0)
	{
		UNPROTECT_PTR(eval);
		PROTECT(VECTOR_ELT(eval, 0));
		PROTECT(VECTOR_ELT(eval, 1));
		return constructNode_and(deMorgan_transform(VECTOR_ELT(eval, 0)), deMorgan_transform(VECTOR_ELT(eval, 1)));
	} else
	if(strcmp(class, "node.NOT")==0)
	{
		UNPROTECT_PTR(eval);
		PROTECT(VECTOR_ELT(eval, 0));		
		eval = VECTOR_ELT(eval, 0);
		return deMorgan_transform_NOT(eval);
	} else
	// we're at the bottom
	return eval;
}



typedef struct {
	SEXP root;
	SEXP refTable;
	SEXP predTable;
	SEXP topoTable;
	int error;
} feedback_t;

void* _alloc_proc(size_t n)
{
	return R_alloc(n, 1);
}

void _free_proc(void* p)
{
}


#include "parser.h"
#include "parser.c"
#include "lexer.c"


SEXP parse(SEXP str)
{
	const char* start = CHAR(STRING_ELT(str, 0));
	const char* query_string = start;
	void* pParser = ParseAlloc (_alloc_proc);
	token_t t;
	feedback_t feed;	
	const char* last_token;
	SEXP result;

	feed.root = R_NilValue;
	feed.refTable = R_NilValue;
	feed.predTable = R_NilValue;
	feed.topoTable = R_NilValue;
	feed.error = 0;
		
	while(*query_string != 0x00)
	{
		last_token = query_string;
		query_string = scan(query_string, &t);
		if(!query_string) goto parse_error;
				
		if(t.type != 0)
			Parse(pParser, t.type, t.token, &feed);
			
		if(feed.error == 1) goto parse_error;	
	}
	
	Parse(pParser, 0, R_NilValue, &feed);
	if(feed.error == 1) goto parse_error;
	
	UNPROTECT(1);

	if(feed.refTable != R_NilValue)  UNPROTECT_PTR(feed.refTable);
	if(feed.predTable != R_NilValue) UNPROTECT_PTR(feed.predTable);
	if(feed.topoTable != R_NilValue) UNPROTECT_PTR(feed.topoTable);
	
	PROTECT(result = allocVector(VECSXP, 4));
	SET_VECTOR_ELT(result, 0, feed.root);
	SET_VECTOR_ELT(result, 1, feed.refTable);
	SET_VECTOR_ELT(result, 2, feed.predTable);
	SET_VECTOR_ELT(result, 3, feed.topoTable);
	UNPROTECT(1);

	
	return(result);
	
parse_error:
	ParseFree(pParser, _free_proc);
	if(!query_string) 
		error("Unexpected end of string: \n        %s <- HERE\n", start);
	else
		error("Syntax error in: \n        %.*s\n HERE-> %.*s\n        %s\n", last_token - start, start, query_string - last_token, last_token, query_string);
	
	return(result);
}